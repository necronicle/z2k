#!/bin/sh
# /opt/etc/init.d/S99zapret2
# Адаптация официального init.d/openwrt/zapret2 для Keenetic
# Использует модули common/ и config файл вместо hardcoded настроек

# ==============================================================================
# ПУТИ И ПЕРЕМЕННЫЕ
# ==============================================================================

ZAPRET_BASE=/opt/zapret2
ZAPRET_RW=${ZAPRET_RW:-"$ZAPRET_BASE"}
ZAPRET_CONFIG=${ZAPRET_CONFIG:-"$ZAPRET_RW/config"}

# Проверка что zapret2 установлен
[ -d "$ZAPRET_BASE" ] || {
    echo "ERROR: zapret2 not installed in $ZAPRET_BASE"
    exit 1
}

# ==============================================================================
# SOURCE ОФИЦИАЛЬНЫХ МОДУЛЕЙ (как в init.d/openwrt/functions)
# ==============================================================================

# Базовые утилиты
. "$ZAPRET_BASE/common/base.sh"

# Определение типа firewall (iptables/nftables)
. "$ZAPRET_BASE/common/fwtype.sh"

# KEENETIC FIX: Переопределить linux_ipt_avail для работы без ip6tables
# На Keenetic может быть DISABLE_IPV6=1, но iptables все равно работает
linux_ipt_avail()
{
	# Для Keenetic достаточно только iptables (IPv4-only режим)
	[ -n "$Z2K_DEBUG" ] && echo "DEBUG: linux_ipt_avail() вызвана"
	exists iptables
	local result=$?
	[ -n "$Z2K_DEBUG" ] && echo "DEBUG: exists iptables = $result"
	return $result
}

# IP helper functions
. "$ZAPRET_BASE/common/linux_iphelper.sh"

# Функции для работы с iptables
. "$ZAPRET_BASE/common/ipt.sh"

# Функции для работы с nftables (если доступны)
existf zapret_do_firewall_nft || . "$ZAPRET_BASE/common/nft.sh" 2>/dev/null

# Управление firewall
. "$ZAPRET_BASE/common/linux_fw.sh"

# Управление daemon процессами
. "$ZAPRET_BASE/common/linux_daemons.sh"

# Работа со списками доменов
. "$ZAPRET_BASE/common/list.sh"

# Поддержка custom scripts
. "$ZAPRET_BASE/common/custom.sh"

# ==============================================================================
# ЗАГРУЗКА КОНФИГУРАЦИИ
# ==============================================================================

# Загрузить конфигурацию
. "$ZAPRET_CONFIG"

# DEBUG: Проверить FWTYPE после загрузки config
[ -n "$Z2K_DEBUG" ] && echo "DEBUG: После загрузки config - FWTYPE='$FWTYPE'"

# КРИТИЧНО: Преобразовать порты в формат iptables (заменить - на :)
# std_ports() была вызвана при загрузке ipt.sh, но тогда переменные были пустые
# Повторно вызвать std_ports() ПОСЛЕ загрузки config
std_ports
[ -n "$Z2K_DEBUG" ] && echo "DEBUG: std_ports() вызвана - NFQWS2_PORTS_TCP_IPT='$NFQWS2_PORTS_TCP_IPT'"

# ------------------------------------------------------------------------------
# ВХОДЯЩИЙ ТРАФИК ДЛЯ ORCHESTRATION (STRICT MANUAL MODE)
# ------------------------------------------------------------------------------
# Для корректной работы оркестраторов (например, circular) требуется видеть
# входящие RST/redirect и т.п. Поэтому включаем входящие правила по умолчанию.
[ -z "$NFQWS2_TCP_PKT_IN" ] && NFQWS2_TCP_PKT_IN="$NFQWS2_TCP_PKT_OUT"
[ -z "$NFQWS2_UDP_PKT_IN" ] && NFQWS2_UDP_PKT_IN="$NFQWS2_UDP_PKT_OUT"

# ------------------------------------------------------------------------------
# AUTOHOSTLIST: ensure required files exist to avoid nfqws2 start failures
# ------------------------------------------------------------------------------
ensure_autohostlist_files()
{
	[ "$MODE_FILTER" = "autohostlist" ] || return 0
	local base="${HOSTLIST_BASE:-$ZAPRET_BASE/ipset}"
	mkdir -p "$base" || return 1
	local auto="$base/zapret-hosts-auto.txt"
	local debuglog="$base/zapret-hosts-auto-debug.log"
	[ -f "$auto" ] || : > "$auto"
	[ "$AUTOHOSTLIST_DEBUGLOG" = "1" ] && [ -f "$debuglog" ] || : > "$debuglog"
}
# ==============================================================================
# НАСТРОЙКИ СПЕЦИФИЧНЫЕ ДЛЯ KEENETIC
# ==============================================================================

PIDDIR=/var/run
USEROPT=""
[ -n "$WS_USER" ] && USEROPT="--user=$WS_USER"
NFQWS2="${NFQWS2:-$ZAPRET_BASE/nfq2/nfqws2}"
LUA_LIB="$ZAPRET_BASE/lua/zapret-lib.lua"
[ -f "$LUA_LIB" ] || LUA_LIB="$LUA_LIB.gz"
LUA_ANTIDPI="$ZAPRET_BASE/lua/zapret-antidpi.lua"
[ -f "$LUA_ANTIDPI" ] || LUA_ANTIDPI="$LUA_ANTIDPI.gz"
LUAOPT="--lua-init=@$LUA_LIB --lua-init=@$LUA_ANTIDPI"
LUA_AUTO="$ZAPRET_BASE/lua/zapret-auto.lua"
[ -f "$LUA_AUTO" ] || LUA_AUTO="$LUA_AUTO.gz"
[ -f "$LUA_AUTO" ] && LUAOPT="$LUAOPT --lua-init=@$LUA_AUTO"
NFQWS2_OPT_BASE="$USEROPT --fwmark=$DESYNC_MARK $LUAOPT"

# Load custom TLS ClientHello blob for strategies (manual: --blob is engine init option).
TLS_MAX_RU_BLOB="$ZAPRET_BASE/files/fake/tls_clienthello_max_ru.bin"
[ -s "$TLS_MAX_RU_BLOB" ] && NFQWS2_OPT_BASE="$NFQWS2_OPT_BASE --blob=tls_max_ru:@$TLS_MAX_RU_BLOB"
LISTS_DIR="$ZAPRET_BASE/lists"
EXTRA_STRATS_DIR="$ZAPRET_BASE/extra_strats"
CONFIG_DIR="/opt/etc/zapret2"
CUSTOM_DIR="${CUSTOM_DIR:-$ZAPRET_RW/init.d/keenetic}"
IPSET_CR="$ZAPRET_BASE/ipset/create_ipset.sh"

# ==============================================================================
# ФУНКЦИИ ДЛЯ РАБОТЫ С IPSET
# ==============================================================================

create_ipset()
{
	echo "Creating ip list table (firewall type $FWTYPE)"
	"$IPSET_CR" "$@"
}

# ==============================================================================
# KEENETIC FIREWALL FUNCTIONS (замена OpenWrt network.sh зависимостей)
# ==============================================================================

get_default_ifaces4()
{
	exists ip || return 0
	ip route show default 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i=="dev") print $(i+1)}' | xargs
}

get_default_ifaces6()
{
	exists ip || return 0
	ip -6 route show default 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i=="dev") print $(i+1)}' | xargs
}

get_wan_ifaces4()
{
	local ifaces
	if [ -n "$WAN_IFACE" ]; then
		ifaces="$(echo "$WAN_IFACE" | tr ',' ' ')"
	else
		ifaces="$(get_default_ifaces4)"
	fi
	ifaces="$(echo "$ifaces" | xargs)"
	if [ -n "$ifaces" ] && exists ip; then
		local i
		for i in $ifaces; do
			ip link show "$i" >/dev/null 2>&1 || echo "WARN: WAN iface '$i' not found"
		done
	fi
	[ -n "$ifaces" ] && unique $ifaces || true
}

get_wan_ifaces6()
{
	local ifaces
	if [ -n "$WAN_IFACE" ]; then
		ifaces="$(echo "$WAN_IFACE" | tr ',' ' ')"
	else
		ifaces="$(get_default_ifaces6)"
	fi
	ifaces="$(echo "$ifaces" | xargs)"
	if [ -n "$ifaces" ] && exists ip; then
		local i
		for i in $ifaces; do
			ip link show "$i" >/dev/null 2>&1 || echo "WARN: WAN iface '$i' not found"
		done
	fi
	[ -n "$ifaces" ] && unique $ifaces || true
}

# Keenetic-specific: упрощенные версии fw_nfqws_post4/post6/pre4/pre6
# В отличие от OpenWrt, не требуют network.sh и определения WAN интерфейсов
# Пытаемся определить WAN по default route

fw_nfqws_post4()
{
	# $1 - 1 - add, 0 - del
	# $2 - filter
	# $3 - queue number
	local wan
	wan="$(get_wan_ifaces4)"
	if [ -n "$wan" ]; then
		_fw_nfqws_post4 "$1" "$2" "$3" "$wan"
	else
		echo "WARN: WAN iface not found (IPv4), skip applying nfqws rules"
		return 0
	fi
}

fw_nfqws_post6()
{
	# $1 - 1 - add, 0 - del
	# $2 - filter
	# $3 - queue number
	[ "$DISABLE_IPV6" = "1" ] && return 0
	local wan
	wan="$(get_wan_ifaces6)"
	if [ -n "$wan" ]; then
		_fw_nfqws_post6 "$1" "$2" "$3" "$wan"
	else
		echo "WARN: WAN iface not found (IPv6), skip applying nfqws rules"
		return 0
	fi
}

fw_nfqws_pre4()
{
	# $1 - 1 - add, 0 - del
	# $2 - filter
	# $3 - queue number
	local wan
	wan="$(get_wan_ifaces4)"
	if [ -n "$wan" ]; then
		_fw_nfqws_pre4 "$1" "$2" "$3" "$wan"
	else
		echo "WARN: WAN iface not found (IPv4), skip applying nfqws rules"
		return 0
	fi
}

fw_nfqws_pre6()
{
	# $1 - 1 - add, 0 - del
	# $2 - filter
	# $3 - queue number
	[ "$DISABLE_IPV6" = "1" ] && return 0
	local wan
	wan="$(get_wan_ifaces6)"
	if [ -n "$wan" ]; then
		_fw_nfqws_pre6 "$1" "$2" "$3" "$wan"
	else
		echo "WARN: WAN iface not found (IPv6), skip applying nfqws rules"
		return 0
	fi
}

# ==============================================================================
# ФУНКЦИИ УПРАВЛЕНИЯ DAEMON (АДАПТИРОВАНО ДЛЯ KEENETIC БЕЗ PROCD)
# ==============================================================================

run_daemon()
{
    # $1 - daemon ID
    # $2 - daemon binary
    # $3 - daemon args
    local DAEMONBASE="$(basename "$2")"
    local PIDFILE="$PIDDIR/${DAEMONBASE}_$1.pid"

    echo "Starting daemon $1: $2 $3"

    # Запуск в фоне с сохранением PID
    $2 $3 >/dev/null 2>&1 &
    local PID=$!

    # Сохранить PID
    echo $PID > "$PIDFILE"

    # Проверить что процесс запустился
    sleep 1
    if kill -0 $PID 2>/dev/null; then
        echo "Daemon $1 started with PID $PID"
        return 0
    else
        echo "ERROR: Daemon $1 failed to start"
        rm -f "$PIDFILE"
        return 1
    fi
}

extract_hostlist_paths()
{
	echo "$1" | tr ' ' '\n' | sed -n 's/^--hostlist=//p'
}

has_hostlist_domains()
{
	echo "$1" | tr ' ' '\n' | grep -q '^--hostlist-domains='
}

validate_profile_hostlist()
{
	local opts="$1"
	local has_hostlist=0
	local has_domains=0
	local path

	for path in $(extract_hostlist_paths "$opts"); do
		has_hostlist=1
		if [ ! -f "$path" ]; then
			echo "WARN: hostlist file not found: $path (skip daemon)"
			return 1
		fi
		if [ ! -s "$path" ]; then
			echo "WARN: hostlist file empty: $path (profile may be ineffective)"
		fi
	done

	if has_hostlist_domains "$opts"; then
		has_domains=1
	fi

	if [ $has_hostlist -eq 0 ] && [ $has_domains -eq 0 ]; then
		echo "WARN: NFQWS2_OPT has no hostlist/hostlist-domains (skip daemon)"
		return 1
	fi

	return 0
}
run_nfqws()
{
    # $1 - instance ID
    # $2 - nfqws options
    validate_profile_hostlist "$2" || return 0
    run_daemon $1 "$NFQWS2" "$NFQWS2_OPT_BASE $2"
}

do_nfqws()
{
    # $1 - 0 (stop) or 1 (start)
    # $2 - instance ID
    # $3 - nfqws options
    [ "$1" = 0 ] || { shift; run_nfqws "$@"; }
}

stop_daemon_by_pidfile()
{
    # $1 - pidfile path
    if [ -f "$1" ]; then
        local PID=$(cat "$1")
        if [ -n "$PID" ] && kill -0 $PID 2>/dev/null; then
            echo "Stopping daemon with PID $PID"
            kill $PID 2>/dev/null
            sleep 1
            # Force kill если не остановился
            kill -0 $PID 2>/dev/null && kill -9 $PID 2>/dev/null
        fi
        rm -f "$1"
    fi
}

stop_all_nfqws()
{
    echo "Stopping all nfqws daemons"

    # Остановить по PID файлам
    for pidfile in $PIDDIR/nfqws2_*.pid; do
        [ -f "$pidfile" ] && stop_daemon_by_pidfile "$pidfile"
    done

    # Fallback: killall если что-то осталось
    killall nfqws2 2>/dev/null

    # Очистить все PID файлы
    rm -f $PIDDIR/nfqws2_*.pid 2>/dev/null
}

# ==============================================================================
# ФУНКЦИИ START/STOP DAEMONS
# ==============================================================================

start_daemons()
{
    echo "Starting zapret2 daemons"

    # Использовать функции из common/linux_daemons.sh
    # standard_mode_daemons вызывает do_nfqws
    standard_mode_daemons 1

    # Запустить custom scripts если есть
    custom_runner zapret_custom_daemons 1

    return 0
}

stop_daemons()
{
    echo "Stopping zapret2 daemons"

    # Остановить все nfqws процессы
    stop_all_nfqws

    # Запустить custom scripts для остановки
    custom_runner zapret_custom_daemons 0

    return 0
}

restart_daemons()
{
    stop_daemons
    sleep 2
    start_daemons
}

# ==============================================================================
# ФУНКЦИИ START/STOP FIREWALL
# ==============================================================================

load_modules()
{
    echo "Loading required kernel modules"

    # Список необходимых модулей для работы zapret2
    local modules="xt_multiport xt_connbytes xt_NFQUEUE nfnetlink_queue"

    for module in $modules; do
        if ! lsmod | grep -q "^$module"; then
            [ -n "$Z2K_DEBUG" ] && echo "DEBUG: Loading module: $module"
            modprobe "$module" 2>/dev/null || {
                echo "Warning: Failed to load module $module (may be built-in)"
            }
        else
            [ -n "$Z2K_DEBUG" ] && echo "DEBUG: Module already loaded: $module"
        fi
    done

    # Проверить критичный модуль nfnetlink_queue
    if ! lsmod | grep -q "nfnetlink_queue" && ! modinfo nfnetlink_queue >/dev/null 2>&1; then
        echo "WARNING: nfnetlink_queue module not available!"
        echo "nfqws2 may fail with 'Operation not permitted'"
        return 1
    fi

    echo "Kernel modules loaded"
    return 0
}

start_fw()
{
    echo "Applying zapret2 firewall rules"

    # DEBUG: Проверить FWTYPE перед linux_fwtype
    [ -n "$Z2K_DEBUG" ] && echo "DEBUG: В start_fw() перед linux_fwtype - FWTYPE='$FWTYPE'"

    # Определить тип firewall (iptables/nftables)
    linux_fwtype

    # DEBUG: Проверить FWTYPE после linux_fwtype
    [ -n "$Z2K_DEBUG" ] && echo "DEBUG: В start_fw() после linux_fwtype - FWTYPE='$FWTYPE'"

    echo "Detected firewall type: $FWTYPE"

    # Использовать официальную функцию из common/linux_fw.sh
    zapret_apply_firewall

    return 0
}

stop_fw()
{
    echo "Removing zapret2 firewall rules"

    # Определить тип firewall
    linux_fwtype

    # Использовать официальную функцию
    zapret_unapply_firewall

    return 0
}

restart_fw()
{
    stop_fw
    sleep 1
    start_fw
}

# ==============================================================================
# OPTIONAL NFTABLES HELPERS (IF AVAILABLE)
# ==============================================================================

reload_ifsets()
{
    existf zapret_reload_ifsets || {
        echo "reload_ifsets not available (nftables functions not loaded)"
        return 1
    }
    zapret_reload_ifsets
}

list_ifsets()
{
    existf zapret_list_ifsets || {
        echo "list_ifsets not available (nftables functions not loaded)"
        return 1
    }
    zapret_list_ifsets
}

list_table()
{
    existf zapret_list_table || {
        echo "list_table not available (nftables functions not loaded)"
        return 1
    }
    zapret_list_table
}

# ==============================================================================
# ОСНОВНЫЕ ФУНКЦИИ START/STOP/RESTART
# ==============================================================================

start()
{
    if [ "$ENABLED" != "1" ]; then
        echo "zapret2 is disabled in config"
        return 1
    fi

    echo "Starting zapret2 service"

    # 1. Загрузить необходимые модули ядра
    load_modules || echo "Warning: Some modules failed to load"

    # 2. Применить firewall правила
    [ "$INIT_APPLY_FW" = "1" ] && start_fw

    # 2.1. Подготовить autohostlist файлы (если включено)
    ensure_autohostlist_files

    # 3. Запустить daemon процессы
    start_daemons

    echo "zapret2 service started"
    return 0
}

stop()
{
    echo "Stopping zapret2 service"

    # 1. Остановить daemon процессы
    stop_daemons

    # 2. Удалить firewall правила
    [ "$INIT_APPLY_FW" = "1" ] && stop_fw

    echo "zapret2 service stopped"
    return 0
}

restart()
{
    stop
    sleep 2
    start
}

status()
{
    echo "Checking zapret2 status..."

    # Проверить процессы по PID файлам
    local running=0
    for pidfile in $PIDDIR/nfqws2_*.pid; do
        if [ -f "$pidfile" ]; then
            local PID=$(cat "$pidfile")
            if kill -0 $PID 2>/dev/null; then
                echo "nfqws2 daemon running (PID $PID)"
                running=$((running + 1))
            else
                echo "Stale PID file: $pidfile"
            fi
        fi
    done

    if [ $running -gt 0 ]; then
        echo "zapret2 is running ($running daemons)"

        # Показать процессы
        echo "Processes:"
        pgrep -af nfqws2

        return 0
    else
        echo "zapret2 is not running"
        return 1
    fi
}

# ==============================================================================
# MAIN
# ==============================================================================

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart)
        restart
        ;;
    status)
        status
        ;;
    start_fw)
        start_fw
        ;;
    stop_fw)
        stop_fw
        ;;
    restart_fw)
        restart_fw
        ;;
    start_daemons)
        start_daemons
        ;;
    stop_daemons)
        stop_daemons
        ;;
    restart_daemons)
        restart_daemons
        ;;
    reload_ifsets)
        reload_ifsets
        ;;
    list_ifsets)
        list_ifsets
        ;;
    list_table)
        list_table
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status|start_fw|stop_fw|restart_fw|start_daemons|stop_daemons|restart_daemons|reload_ifsets|list_ifsets|list_table}"
        exit 1
        ;;
esac

exit $?
